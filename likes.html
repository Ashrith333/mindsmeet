<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Likes - Minds Meet</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #3fa2ed;
      --primary-dark: #2d8fd8;
      --text-primary: #111518;
      --text-secondary: #617889;
      --bg-input: #f0f3f4;
      --nav-bg: #3fa2ed;
      --nav-active: #fff;
      --nav-inactive: #b6dafe;
    }
    body {
      font-family: 'Plus Jakarta Sans', sans-serif;
      background: #fff;
      min-height: 100vh;
    }
    .bottom-nav {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      background: #fff;
      border-top: 1px solid #e5e7eb;
      z-index: 50;
      display: flex;
      justify-content: space-around;
      align-items: center;
      height: 64px;
    }
    .nav-icon {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px;
      border: none;
      background: none;
      color: #6b7280;
      font-size: 12px;
      cursor: pointer;
      transition: color 0.2s;
      position: relative;
    }
    .nav-icon.active {
      color: #3b82f6;
    }
    .nav-icon:hover {
      color: #3b82f6;
    }
    .like-card {
      transition: transform 0.2s;
    }
    .like-card:hover {
      transform: translateY(-2px);
    }
    .unread-indicator {
      position: absolute !important;
      top: -4px !important;
      right: -4px !important;
      width: 12px !important;
      height: 12px !important;
      background-color: #3b82f6 !important;
      border-radius: 50% !important;
      z-index: 10 !important;
    }
  </style>
</head>
<body class="min-h-screen flex flex-col bg-white">
  <!-- Top Safe Area for iOS Notch -->
  <div style="height: env(safe-area-inset-top, 24px);"></div>
  
  <!-- Header -->
  <div class="flex items-center justify-between px-4 py-3 bg-white border-b border-gray-100 sticky top-0 z-40">
    <div class="flex items-center">
      <div class="rounded-full bg-blue-100 flex items-center justify-center w-9 h-9 text-xl font-bold text-primary select-none">M</div>
      <h1 class="ml-3 text-xl font-bold text-primary">Likes</h1>
    </div>
    <button class="text-primary" aria-label="Settings">
      <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
      </svg>
    </button>
  </div>

  <!-- Main Content -->
  <div class="flex-1 w-full max-w-lg mx-auto pt-16 pb-20 bg-gray-50 overflow-y-auto" style="min-height:calc(100vh - 120px);">
    <!-- Likes Content -->
    <div class="p-4">
      <h2 class="text-2xl font-bold text-primary mb-6">People who liked you</h2>
      
      <!-- Likes Grid -->
      <div id="likesGrid" class="grid grid-cols-2 gap-4">
        <!-- Dynamic content will be loaded here -->
      </div>
    </div>

    <!-- Empty State (hidden by default) -->
    <div id="emptyState" class="hidden flex flex-col items-center justify-center py-16 px-4">
      <div class="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mb-4">
        <svg class="w-8 h-8 text-gray-400" fill="currentColor" viewBox="0 0 24 24">
          <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
        </svg>
      </div>
      <h3 class="text-lg font-semibold text-primary mb-2">No likes yet</h3>
      <p class="text-gray-600 text-center mb-6">Start browsing profiles to get likes!</p>
      <button onclick="window.location.href='browse.html'" class="bg-primary text-white px-6 py-2 rounded-full font-medium">
        Start Browsing
      </button>
    </div>
  </div>

  <!-- Bottom Navigation Bar -->
  <nav class="bottom-nav">
    <button class="nav-icon" onclick="window.location.href='browse.html'">
      <svg class="w-7 h-7 mb-1" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3"></path></svg>
      Browse
    </button>
    <button class="nav-icon" onclick="window.location.href='messages.html'">
      <svg class="w-7 h-7 mb-1" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M8 10h.01M12 10h.01M16 10h.01M21 12c0 4.418-4.03 8-9 8s-9-3.582-9-8a9 9 0 1118 0z"></path></svg>
      Messages
    </button>
    <button class="nav-icon active" onclick="window.location.href='likes.html'">
      <svg class="w-7 h-7 mb-1" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7"></path></svg>
      Likes
    </button>
    <button class="nav-icon" onclick="window.location.href='profile.html'">
      <svg class="w-7 h-7 mb-1" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M5.121 17.804A13.937 13.937 0 0112 15c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
      Profile
    </button>
  </nav>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script>
    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBkEbvGk_kxL3d1IB2zgYFpbixUBJ8EV8c",
      authDomain: "mindsmeet-a8945.firebaseapp.com",
      projectId: "mindsmeet-a8945",
      storageBucket: "mindsmeet-a8945.firebasestorage.app",
      messagingSenderId: "273248409523",
      appId: "1:273248409523:web:88fc2d8eefacc665c8ddc6",
      measurementId: "G-H8QD41XT3P"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // Check authentication on page load
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Likes page loaded, checking authentication...');
      
      auth.onAuthStateChanged(function(user) {
        console.log('Auth state changed:', user ? 'User logged in' : 'No user');
        
        if (user && user.email) {
          console.log('User authenticated:', user.email);
          console.log('Email verified:', user.emailVerified);
          
          // Check if user has complete profile
          checkUserProfile(user);
        } else {
          console.log('No user authenticated, redirecting to login');
          window.location.href = 'login.html';
        }
      });
    });

    // Check if user has complete profile
    async function checkUserProfile(user) {
      try {
        console.log('Checking user profile completion...');
        
        const userDocRef = db.collection('users').doc(user.email);
        const userSnap = await userDocRef.get();
        
        if (userSnap.exists) {
          const userData = userSnap.data();
          console.log('User profile data:', userData);
          
          // Check if essential profile data exists
          if (!userData.fullName || !userData.age) {
            window.location.href = 'profile-setup.html';
            return;
          }
          
          // Check if profile has essential data (name, age, etc.)
          // For existing profiles, dating preferences is optional
          // For new profiles, it will be required during setup
          const hasEssentialData = userData.fullName && userData.age;
          console.log('Has essential profile data:', hasEssentialData);
          
          if (hasEssentialData) {
            // Profile exists with essential data - load likes
            console.log('Profile complete, loading likes');
            loadLikes();
            
            // Setup message notifications
            setupMessageNotifications();
          } else {
            // Profile exists but missing essential data - go to profile setup
            console.log('Profile incomplete, redirecting to profile setup');
            window.location.href = 'profile-setup.html?email=' + encodeURIComponent(user.email);
          }
        } else {
          // No profile data found - go to profile setup
          console.log('No profile data found, redirecting to profile setup');
          window.location.href = 'profile-setup.html?email=' + encodeURIComponent(user.email);
        }
      } catch (error) {
        console.error('Error checking user profile:', error);
        alert('Error checking profile. Please try again.');
      }
    }

    // Load likes
    async function loadLikes() {
      try {
        console.log('Loading likes...');
        const user = auth.currentUser;
        if (!user) return;

        // Fetch likes where current user is the target
        const likesSnapshot = await db.collection('likes').where('toUser', '==', user.email).where('status', '==', 'like').get();
        
        const likesGrid = document.getElementById('likesGrid');
        const emptyState = document.getElementById('emptyState');
        
        // Clear existing content
        likesGrid.innerHTML = '';
        
        let likesFound = 0;
        
        // Get all user profiles to match with likes
        const usersSnapshot = await db.collection('users').get();
        const userProfiles = {};
        usersSnapshot.forEach(doc => {
          userProfiles[doc.id] = doc.data();
        });
        
        // Get existing conversations to filter out matched users
        const conversationsSnapshot = await db.collection('conversations').where('participants', 'array-contains', user.email).get();
        const matchedUsers = new Set();
        conversationsSnapshot.forEach(doc => {
          const conversationData = doc.data();
          conversationData.participants.forEach(userEmail => {
            if (userEmail !== user.email) {
              matchedUsers.add(userEmail);
            }
          });
        });
        
        // Also check for existing likes from current user to filter out mutual likes
        const currentUserLikesSnapshot = await db.collection('likes').where('fromUser', '==', user.email).get();
        const currentUserLikes = {};
        currentUserLikesSnapshot.forEach(doc => {
          const likeData = doc.data();
          currentUserLikes[likeData.toUser] = likeData.status;
        });
        
        console.log('Matched users:', Array.from(matchedUsers));
        console.log('Current user likes:', currentUserLikes);
        
        likesSnapshot.forEach(doc => {
          const likeData = doc.data();
          const likerEmail = likeData.fromUser;
          const likerProfile = userProfiles[likerEmail];
          
          // Skip if user is already matched (they should be in messages)
          if (matchedUsers.has(likerEmail)) {
            console.log('Skipping matched user from likes:', likerEmail);
            return;
          }
          
          // Skip if current user has already liked/disliked this user
          if (currentUserLikes[likerEmail]) {
            console.log(`Skipping user that current user has already ${currentUserLikes[likerEmail]}:`, likerEmail);
            return;
          }
          
          if (likerProfile && likerProfile.fullName && likerProfile.age) {
            likesFound++;
            
            // Get profile photo
            const photos = likerProfile.photos || [];
            const mainPhoto = photos.length > 0 ? photos[0].url : 'https://randomuser.me/api/portraits/lego/1.jpg';
            
            // Calculate age from birth date if available
            let age = likerProfile.age;
            if (likerProfile.birthDate) {
              const birthDate = new Date(likerProfile.birthDate);
              const today = new Date();
              age = today.getFullYear() - birthDate.getFullYear();
              const monthDiff = today.getMonth() - birthDate.getMonth();
              if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
                age--;
              }
            }
            
            // Create like card
            const likeCard = document.createElement('div');
            likeCard.className = 'like-card bg-white rounded-2xl shadow-sm border border-gray-100 overflow-hidden cursor-pointer';
            likeCard.dataset.userEmail = likerEmail;
            
            likeCard.innerHTML = `
              <div class="relative">
                <img src="${mainPhoto}" class="w-full h-48 object-cover" alt="Profile">
                <div class="absolute top-2 right-2 bg-white rounded-full p-1">
                  <svg class="w-4 h-4 text-red-500" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                  </svg>
                </div>
              </div>
              <div class="p-3">
                <h3 class="font-semibold text-primary text-sm">${likerProfile.fullName}, ${age}</h3>
                <p class="text-xs text-gray-600 mt-1">${likerProfile.currentLocation || 'Location not set'}</p>
                <p class="text-xs text-green-600 mt-1 font-medium">Liked you ${formatTimeAgo(likeData.timestamp)}</p>
                
                <!-- Action buttons -->
                <div class="flex space-x-2 mt-3">
                  <button onclick="event.stopPropagation(); handleDislikeFromLikes('${likerEmail}')" class="flex-1 bg-red-500 hover:bg-red-600 text-white text-xs py-2 px-3 rounded-full transition-colors">
                    <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                    Pass
                  </button>
                  <button onclick="event.stopPropagation(); handleLikeFromLikes('${likerEmail}')" class="flex-1 bg-green-500 hover:bg-green-600 text-white text-xs py-2 px-3 rounded-full transition-colors">
                    <svg class="w-4 h-4 inline mr-1" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/>
                    </svg>
                    Like Back
                  </button>
                </div>
              </div>
            `;
            
            likesGrid.appendChild(likeCard);
          }
        });
        
        // Show empty state if no likes
        if (likesFound === 0) {
          likesGrid.classList.add('hidden');
          emptyState.classList.remove('hidden');
        } else {
          likesGrid.classList.remove('hidden');
          emptyState.classList.add('hidden');
        }
        
        console.log(`Loaded ${likesFound} likes (excluding ${matchedUsers.size} matched users and ${Object.keys(currentUserLikes).length} already interacted users)`);
        
      } catch (error) {
        console.error('Error loading likes:', error);
        const likesGrid = document.getElementById('likesGrid');
        const emptyState = document.getElementById('emptyState');
        
        likesGrid.classList.add('hidden');
        emptyState.classList.remove('hidden');
        
        // Update empty state message for error
        const emptyStateTitle = emptyState.querySelector('h3');
        const emptyStateDesc = emptyState.querySelector('p');
        if (emptyStateTitle) emptyStateTitle.textContent = 'Error loading likes';
        if (emptyStateDesc) emptyStateDesc.textContent = 'Please try again later';
      }
    }

    // Format timestamp to "time ago" format
    function formatTimeAgo(timestamp) {
      if (!timestamp) return 'recently';
      
      const now = new Date();
      const time = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
      const diffInSeconds = Math.floor((now - time) / 1000);
      
      if (diffInSeconds < 60) return 'just now';
      if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
      if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
      return `${Math.floor(diffInSeconds / 86400)}d ago`;
    }

    // Handle like card clicks
    function handleLikeCardClick(userEmail) {
      console.log('Like card clicked for user:', userEmail);
      // TODO: Navigate to profile view or show profile modal
      // For now, just log the click
      alert(`Viewing profile of ${userEmail}`);
    }

    // Handle like action from likes section
    async function handleLikeFromLikes(userEmail) {
      try {
        const currentUser = auth.currentUser;
        if (!currentUser) {
          console.log('No current user found');
          return;
        }

        console.log(`Liking back user: ${userEmail}`);
        
        // Create or update like document
        const likeRef = db.collection('likes').doc(`${currentUser.email}_${userEmail}`);
        await likeRef.set({
          fromUser: currentUser.email,
          toUser: userEmail,
          status: 'like',
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        // Check if it's a match (other user already liked current user)
        await checkForMatchFromLikes(userEmail);
        
        // Remove the like card from the UI
        removeLikeCard(userEmail);
        
      } catch (error) {
        console.error('Error liking user from likes:', error);
        alert('Error liking user. Please try again.');
      }
    }

    // Handle dislike action from likes section
    async function handleDislikeFromLikes(userEmail) {
      try {
        const currentUser = auth.currentUser;
        if (!currentUser) {
          console.log('No current user found');
          return;
        }

        console.log(`Disliking user from likes: ${userEmail}`);
        
        // Create or update like document
        const likeRef = db.collection('likes').doc(`${currentUser.email}_${userEmail}`);
        await likeRef.set({
          fromUser: currentUser.email,
          toUser: userEmail,
          status: 'dislike',
          timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        // Remove the like card from the UI
        removeLikeCard(userEmail);
        
      } catch (error) {
        console.error('Error disliking user from likes:', error);
        alert('Error disliking user. Please try again.');
      }
    }

    // Check for match when liking back from likes section
    async function checkForMatchFromLikes(userEmail) {
      try {
        const currentUser = auth.currentUser;
        if (!currentUser) return;
        
        // Check if the other user also liked current user
        const otherUserLikeRef = db.collection('likes').doc(`${userEmail}_${currentUser.email}`);
        const otherUserLikeDoc = await otherUserLikeRef.get();
        
        if (otherUserLikeDoc.exists && otherUserLikeDoc.data().status === 'like') {
          // It's a match!
          console.log('Match found from likes section!');
          
          // Create match document
          const matchRef = db.collection('matches').doc(`${currentUser.email}_${userEmail}`);
          await matchRef.set({
            users: [currentUser.email, userEmail].sort(),
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            status: 'active'
          });
          
          // Create conversation for messaging
          await createConversationFromLikes(currentUser.email, userEmail);
          
          // Show match notification
          showMatchNotificationFromLikes(userEmail);
        }
        
      } catch (error) {
        console.error('Error checking for match from likes:', error);
      }
    }

    // Create conversation for matched users from likes section
    async function createConversationFromLikes(user1Email, user2Email) {
      try {
        // Create conversation document
        const conversationId = [user1Email, user2Email].sort().join('_');
        const conversationRef = db.collection('conversations').doc(conversationId);
        
        // Check if conversation already exists
        const conversationDoc = await conversationRef.get();
        
        if (!conversationDoc.exists) {
          // Create new conversation
          await conversationRef.set({
            participants: [user1Email, user2Email].sort(),
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            lastMessage: null,
            lastMessageTime: null,
            lastMessageSender: 'system'
          });
          
          // Create initial welcome message
          const messageRef = conversationRef.collection('messages').doc();
          await messageRef.set({
            sender: 'system',
            text: 'You matched! Start a conversation! ðŸ’•',
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            type: 'system'
          });
          
          // Update conversation with last message
          await conversationRef.update({
            lastMessage: 'You matched! Start a conversation! ðŸ’•',
            lastMessageTime: firebase.firestore.FieldValue.serverTimestamp(),
            lastMessageSender: 'system'
          });
          
          console.log('Conversation created for match from likes:', conversationId);
        }
        
      } catch (error) {
        console.error('Error creating conversation from likes:', error);
      }
    }

    // Show match notification from likes section
    function showMatchNotificationFromLikes(userEmail) {
      // Create notification element
      const notification = document.createElement('div');
      notification.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 animate-bounce';
      notification.innerHTML = `
        <div class="flex items-center space-x-2">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"/>
          </svg>
          <span class="font-medium">It's a match! ðŸŽ‰</span>
        </div>
      `;
      
      document.body.appendChild(notification);
      
      // Remove notification after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    }

    // Remove like card from UI
    function removeLikeCard(userEmail) {
      const card = document.querySelector(`[data-user-email="${userEmail}"]`);
      if (card) {
        // Add fade out animation
        card.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
        card.style.opacity = '0';
        card.style.transform = 'translateX(-100%)';
        
        // Remove from DOM after animation
        setTimeout(() => {
          if (card.parentNode) {
            card.parentNode.removeChild(card);
          }
          
          // Check if no more likes
          const remainingCards = document.querySelectorAll('.like-card');
          if (remainingCards.length === 0) {
            const likesGrid = document.getElementById('likesGrid');
            const emptyState = document.getElementById('emptyState');
            
            likesGrid.classList.add('hidden');
            emptyState.classList.remove('hidden');
          }
        }, 300);
      }
    }

    // Load user profile
    async function loadUserProfile() {
      try {
        const user = auth.currentUser;
        if (!user) return;

        const userDoc = await db.collection('users').doc(user.email).get();
        if (!userDoc.exists) {
          window.location.href = 'profile-setup.html';
          return;
        }

        const userData = userDoc.data();
        
        // Check if essential profile data exists
        if (!userData.fullName || !userData.age) {
          window.location.href = 'profile-setup.html';
          return;
        }

        // Load likes data
        loadLikes();
        
        // Setup message notifications
        setupMessageNotifications();
        
      } catch (error) {
        console.error('Error loading user profile:', error);
        window.location.href = 'profile-setup.html';
      }
    }

    // Setup message notifications
    function setupMessageNotifications() {
      const user = auth.currentUser;
      if (!user) return;

      console.log('Setting up message notifications in likes');

      // First, check for existing unread messages
      checkForUnreadMessages();

      // Listen for new conversations (messages)
      db.collection('conversations').where('participants', 'array-contains', user.email)
        .onSnapshot(snapshot => {
          console.log('Likes: Conversation changes detected:', snapshot.docChanges().length);
          
          snapshot.docChanges().forEach(change => {
            console.log('Likes: Change type:', change.type, 'Doc ID:', change.doc.id);
            
            if (change.type === 'modified') {
              const conversationData = change.doc.data();
              console.log('Likes: Modified conversation data:', conversationData);
              
              // Check if this is a new message (not from current user, not system)
              if (conversationData.lastMessage && 
                  conversationData.lastMessageSender && 
                  conversationData.lastMessageSender !== 'system' &&
                  conversationData.lastMessageSender !== user.email) {
                console.log('Likes: New message detected:', change.doc.id);
                
                // Get sender's name for notification
                const otherUserEmail = conversationData.participants.find(email => email !== user.email);
                if (otherUserEmail) {
                  db.collection('users').doc(otherUserEmail).get().then(userDoc => {
                    if (userDoc.exists) {
                      const senderProfile = userDoc.data();
                      // Don't immediately set blue dot to true, check unread status instead
                      setTimeout(() => {
                        checkForUnreadMessages();
                      }, 100);
                      console.log('Likes: Checking unread messages instead of setting blue dot');
                    }
                  });
                }
              }
            }
          });
          
          // Check for unread messages after any changes
          setTimeout(() => {
            checkForUnreadMessages();
          }, 100);
        }, error => {
          console.error('Error setting up message notifications:', error);
        });
    }

    // Check for unread messages across all conversations
    async function checkForUnreadMessages() {
      const user = auth.currentUser;
      if (!user) return;

      try {
        console.log('Checking for unread messages...');
        
        const conversationsSnapshot = await db.collection('conversations').where('participants', 'array-contains', user.email).get();
        let hasUnread = false;
        
        conversationsSnapshot.forEach(doc => {
          const conversationData = doc.data();
          // Check if this conversation has unread messages (last message is not from current user)
          if (conversationData.lastMessage && 
              conversationData.lastMessageSender && 
              conversationData.lastMessageSender !== 'system' &&
              conversationData.lastMessageSender !== user.email) {
            
            // Check if the current user has read this message
            const readBy = conversationData.readBy || {};
            const lastMessageTime = conversationData.lastMessageTime;
            const userReadTime = readBy[user.email];
            
            // Message is unread if:
            // 1. There's a last message from someone else
            // 2. AND either no read timestamp OR read timestamp is before last message time
            const isUnread = !userReadTime || 
                            (lastMessageTime && userReadTime.toDate && lastMessageTime.toDate && 
                             userReadTime.toDate() < lastMessageTime.toDate());
            
            if (isUnread) {
              hasUnread = true;
              console.log('Found unread message in conversation:', doc.id);
            }
          }
        });
        
        console.log('Unread messages found:', hasUnread);
        updateMessagesIndicator(hasUnread);
        
      } catch (error) {
        console.error('Error checking for unread messages:', error);
      }
    }

    // Update messages indicator in navigation
    function updateMessagesIndicator(hasUnread) {
      console.log('Likes: Updating messages indicator, hasUnread:', hasUnread);
      
      // Update the messages icon in the bottom navigation
      const messagesNavButton = document.querySelector('[onclick*="messages.html"]');
      console.log('Likes: Messages nav button found:', !!messagesNavButton);
      
      if (messagesNavButton) {
        // Make sure the button has relative positioning for the indicator
        messagesNavButton.style.position = 'relative';
        
        const existingIndicator = messagesNavButton.querySelector('.unread-indicator');
        console.log('Likes: Existing indicator found:', !!existingIndicator);
        
        if (hasUnread && !existingIndicator) {
          // Add blue dot indicator
          const indicator = document.createElement('div');
          indicator.className = 'unread-indicator absolute -top-1 -right-1 w-3 h-3 bg-blue-500 rounded-full z-10';
          messagesNavButton.appendChild(indicator);
          console.log('Likes: Blue dot indicator added');
        } else if (!hasUnread && existingIndicator) {
          // Remove blue dot indicator
          existingIndicator.remove();
          console.log('Likes: Blue dot indicator removed');
        }
      }
      
      // Also update the page title to show unread count
      if (hasUnread) {
        document.title = 'Likes (1) - Minds Meet';
      } else {
        document.title = 'Likes - Minds Meet';
      }
    }

    // Check if message is unread
    function isUnread(conversationData) {
      const currentUser = auth.currentUser;
      if (!currentUser || !conversationData.lastMessageSender) return false;
      
      // Message is unread if:
      // 1. It's from the other person (not system or current user)
      // 2. Current user hasn't read it yet (no readBy timestamp)
      const isFromOtherPerson = conversationData.lastMessageSender !== 'system' && 
                               conversationData.lastMessageSender !== currentUser.email;
      
      const hasReadTimestamp = conversationData.readBy && 
                              conversationData.readBy[currentUser.email];
      
      return isFromOtherPerson && !hasReadTimestamp;
    }
  </script>
</body>
</html> 